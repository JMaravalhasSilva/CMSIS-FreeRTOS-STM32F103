#include <LCDdriver.h>


const unsigned char  font[] = {
    0x00, 0x00, 0x00, 0x00, 0x00,
	0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
	0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
	0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
	0x18, 0x3C, 0x7E, 0x3C, 0x18,
	0x1C, 0x57, 0x7D, 0x57, 0x1C,
	0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
	0x00, 0x18, 0x3C, 0x18, 0x00,
	0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
	0x00, 0x18, 0x24, 0x18, 0x00,
	0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
	0x30, 0x48, 0x3A, 0x06, 0x0E,
	0x26, 0x29, 0x79, 0x29, 0x26,
	0x40, 0x7F, 0x05, 0x05, 0x07,
	0x40, 0x7F, 0x05, 0x25, 0x3F,
	0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
	0x7F, 0x3E, 0x1C, 0x1C, 0x08,
	0x08, 0x1C, 0x1C, 0x3E, 0x7F,
	0x14, 0x22, 0x7F, 0x22, 0x14,
	0x5F, 0x5F, 0x00, 0x5F, 0x5F,
	0x06, 0x09, 0x7F, 0x01, 0x7F,
	0x00, 0x66, 0x89, 0x95, 0x6A,
	0x60, 0x60, 0x60, 0x60, 0x60,
	0x94, 0xA2, 0xFF, 0xA2, 0x94,
	0x08, 0x04, 0x7E, 0x04, 0x08,
	0x10, 0x20, 0x7E, 0x20, 0x10,
	0x08, 0x08, 0x2A, 0x1C, 0x08,
	0x08, 0x1C, 0x2A, 0x08, 0x08,
	0x1E, 0x10, 0x10, 0x10, 0x10,
	0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
	0x30, 0x38, 0x3E, 0x38, 0x30,
	0x06, 0x0E, 0x3E, 0x0E, 0x06,
	0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x5F, 0x00, 0x00,
	0x00, 0x07, 0x00, 0x07, 0x00,
	0x14, 0x7F, 0x14, 0x7F, 0x14,
	0x24, 0x2A, 0x7F, 0x2A, 0x12,
	0x23, 0x13, 0x08, 0x64, 0x62,
	0x36, 0x49, 0x56, 0x20, 0x50,
	0x00, 0x08, 0x07, 0x03, 0x00,
	0x00, 0x1C, 0x22, 0x41, 0x00,
	0x00, 0x41, 0x22, 0x1C, 0x00,
	0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
	0x08, 0x08, 0x3E, 0x08, 0x08,
	0x00, 0x80, 0x70, 0x30, 0x00,
	0x08, 0x08, 0x08, 0x08, 0x08,
	0x00, 0x00, 0x60, 0x60, 0x00,
	0x20, 0x10, 0x08, 0x04, 0x02,
	0x3E, 0x51, 0x49, 0x45, 0x3E,
	0x00, 0x42, 0x7F, 0x40, 0x00,
	0x72, 0x49, 0x49, 0x49, 0x46,
	0x21, 0x41, 0x49, 0x4D, 0x33,
	0x18, 0x14, 0x12, 0x7F, 0x10,
	0x27, 0x45, 0x45, 0x45, 0x39,
	0x3C, 0x4A, 0x49, 0x49, 0x31,
	0x41, 0x21, 0x11, 0x09, 0x07,
	0x36, 0x49, 0x49, 0x49, 0x36,
	0x46, 0x49, 0x49, 0x29, 0x1E,
	0x00, 0x00, 0x14, 0x00, 0x00,
	0x00, 0x40, 0x34, 0x00, 0x00,
	0x00, 0x08, 0x14, 0x22, 0x41,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x00, 0x41, 0x22, 0x14, 0x08,
	0x02, 0x01, 0x59, 0x09, 0x06,
	0x3E, 0x41, 0x5D, 0x59, 0x4E,
	0x7C, 0x12, 0x11, 0x12, 0x7C,
	0x7F, 0x49, 0x49, 0x49, 0x36,
	0x3E, 0x41, 0x41, 0x41, 0x22,
	0x7F, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x49, 0x49, 0x49, 0x41,
	0x7F, 0x09, 0x09, 0x09, 0x01,
	0x3E, 0x41, 0x41, 0x51, 0x73,
	0x7F, 0x08, 0x08, 0x08, 0x7F,
	0x00, 0x41, 0x7F, 0x41, 0x00,
	0x20, 0x40, 0x41, 0x3F, 0x01,
	0x7F, 0x08, 0x14, 0x22, 0x41,
	0x7F, 0x40, 0x40, 0x40, 0x40,
	0x7F, 0x02, 0x1C, 0x02, 0x7F,
	0x7F, 0x04, 0x08, 0x10, 0x7F,
	0x3E, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x09, 0x09, 0x09, 0x06,
	0x3E, 0x41, 0x51, 0x21, 0x5E,
	0x7F, 0x09, 0x19, 0x29, 0x46,
	0x26, 0x49, 0x49, 0x49, 0x32,
	0x03, 0x01, 0x7F, 0x01, 0x03,
	0x3F, 0x40, 0x40, 0x40, 0x3F,
	0x1F, 0x20, 0x40, 0x20, 0x1F,
	0x3F, 0x40, 0x38, 0x40, 0x3F,
	0x63, 0x14, 0x08, 0x14, 0x63,
	0x03, 0x04, 0x78, 0x04, 0x03,
	0x61, 0x59, 0x49, 0x4D, 0x43,
	0x00, 0x7F, 0x41, 0x41, 0x41,
	0x02, 0x04, 0x08, 0x10, 0x20,
	0x00, 0x41, 0x41, 0x41, 0x7F,
	0x04, 0x02, 0x01, 0x02, 0x04,
	0x40, 0x40, 0x40, 0x40, 0x40,
	0x00, 0x03, 0x07, 0x08, 0x00,
	0x20, 0x54, 0x54, 0x78, 0x40,
	0x7F, 0x28, 0x44, 0x44, 0x38,
	0x38, 0x44, 0x44, 0x44, 0x28,
	0x38, 0x44, 0x44, 0x28, 0x7F,
	0x38, 0x54, 0x54, 0x54, 0x18,
	0x00, 0x08, 0x7E, 0x09, 0x02,
	0x18, 0xA4, 0xA4, 0x9C, 0x78,
	0x7F, 0x08, 0x04, 0x04, 0x78,
	0x00, 0x44, 0x7D, 0x40, 0x00,
	0x20, 0x40, 0x40, 0x3D, 0x00,
	0x7F, 0x10, 0x28, 0x44, 0x00,
	0x00, 0x41, 0x7F, 0x40, 0x00,
	0x7C, 0x04, 0x78, 0x04, 0x78,
	0x7C, 0x08, 0x04, 0x04, 0x78,
	0x38, 0x44, 0x44, 0x44, 0x38,
	0xFC, 0x18, 0x24, 0x24, 0x18,
	0x18, 0x24, 0x24, 0x18, 0xFC,
	0x7C, 0x08, 0x04, 0x04, 0x08,
	0x48, 0x54, 0x54, 0x54, 0x24,
	0x04, 0x04, 0x3F, 0x44, 0x24,
	0x3C, 0x40, 0x40, 0x20, 0x7C,
	0x1C, 0x20, 0x40, 0x20, 0x1C,
	0x3C, 0x40, 0x30, 0x40, 0x3C,
	0x44, 0x28, 0x10, 0x28, 0x44,
	0x4C, 0x90, 0x90, 0x90, 0x7C,
	0x44, 0x64, 0x54, 0x4C, 0x44,
	0x00, 0x08, 0x36, 0x41, 0x00,
	0x00, 0x00, 0x77, 0x00, 0x00,
	0x00, 0x41, 0x36, 0x08, 0x00,
	0x02, 0x01, 0x02, 0x04, 0x02,
	0x3C, 0x26, 0x23, 0x26, 0x3C,
	0x1E, 0xA1, 0xA1, 0x61, 0x12,
	0x3A, 0x40, 0x40, 0x20, 0x7A,
	0x38, 0x54, 0x54, 0x55, 0x59,
	0x21, 0x55, 0x55, 0x79, 0x41,
	0x21, 0x54, 0x54, 0x78, 0x41,
	0x21, 0x55, 0x54, 0x78, 0x40,
	0x20, 0x54, 0x55, 0x79, 0x40,
	0x0C, 0x1E, 0x52, 0x72, 0x12,
	0x39, 0x55, 0x55, 0x55, 0x59,
	0x39, 0x54, 0x54, 0x54, 0x59,
	0x39, 0x55, 0x54, 0x54, 0x58,
	0x00, 0x00, 0x45, 0x7C, 0x41,
	0x00, 0x02, 0x45, 0x7D, 0x42,
	0x00, 0x01, 0x45, 0x7C, 0x40,
	0xF0, 0x29, 0x24, 0x29, 0xF0,
	0xF0, 0x28, 0x25, 0x28, 0xF0,
	0x7C, 0x54, 0x55, 0x45, 0x00,
	0x20, 0x54, 0x54, 0x7C, 0x54,
	0x7C, 0x0A, 0x09, 0x7F, 0x49,
	0x32, 0x49, 0x49, 0x49, 0x32,
	0x32, 0x48, 0x48, 0x48, 0x32,
	0x32, 0x4A, 0x48, 0x48, 0x30,
	0x3A, 0x41, 0x41, 0x21, 0x7A,
	0x3A, 0x42, 0x40, 0x20, 0x78,
	0x00, 0x9D, 0xA0, 0xA0, 0x7D,
	0x39, 0x44, 0x44, 0x44, 0x39,
	0x3D, 0x40, 0x40, 0x40, 0x3D,
	0x3C, 0x24, 0xFF, 0x24, 0x24,
	0x48, 0x7E, 0x49, 0x43, 0x66,
	0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
	0xFF, 0x09, 0x29, 0xF6, 0x20,
	0xC0, 0x88, 0x7E, 0x09, 0x03,
	0x20, 0x54, 0x54, 0x79, 0x41,
	0x00, 0x00, 0x44, 0x7D, 0x41,
	0x30, 0x48, 0x48, 0x4A, 0x32,
	0x38, 0x40, 0x40, 0x22, 0x7A,
	0x00, 0x7A, 0x0A, 0x0A, 0x72,
	0x7D, 0x0D, 0x19, 0x31, 0x7D,
	0x26, 0x29, 0x29, 0x2F, 0x28,
	0x26, 0x29, 0x29, 0x29, 0x26,
	0x30, 0x48, 0x4D, 0x40, 0x20,
	0x38, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x38,
	0x2F, 0x10, 0xC8, 0xAC, 0xBA,
	0x2F, 0x10, 0x28, 0x34, 0xFA,
	0x00, 0x00, 0x7B, 0x00, 0x00,
	0x08, 0x14, 0x2A, 0x14, 0x22,
	0x22, 0x14, 0x2A, 0x14, 0x08,
	0xAA, 0x00, 0x55, 0x00, 0xAA,
	0xAA, 0x55, 0xAA, 0x55, 0xAA,
	0x00, 0x00, 0x00, 0xFF, 0x00,
	0x10, 0x10, 0x10, 0xFF, 0x00,
	0x14, 0x14, 0x14, 0xFF, 0x00,
	0x10, 0x10, 0xFF, 0x00, 0xFF,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x14, 0x14, 0x14, 0xFC, 0x00,
	0x14, 0x14, 0xF7, 0x00, 0xFF,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x14, 0x14, 0xF4, 0x04, 0xFC,
	0x14, 0x14, 0x17, 0x10, 0x1F,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0x1F, 0x00,
	0x10, 0x10, 0x10, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0xF0, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x10,
	0x10, 0x10, 0x10, 0x10, 0x10,
	0x10, 0x10, 0x10, 0xFF, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x14,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x00, 0x00, 0x1F, 0x10, 0x17,
	0x00, 0x00, 0xFC, 0x04, 0xF4,
	0x14, 0x14, 0x17, 0x10, 0x17,
	0x14, 0x14, 0xF4, 0x04, 0xF4,
	0x00, 0x00, 0xFF, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x14, 0x14, 0xF7, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x17, 0x14,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0xF4, 0x14,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x00, 0x00, 0x1F, 0x10, 0x1F,
	0x00, 0x00, 0x00, 0x1F, 0x14,
	0x00, 0x00, 0x00, 0xFC, 0x14,
	0x00, 0x00, 0xF0, 0x10, 0xF0,
	0x10, 0x10, 0xFF, 0x10, 0xFF,
	0x14, 0x14, 0x14, 0xFF, 0x14,
	0x10, 0x10, 0x10, 0x1F, 0x00,
	0x00, 0x00, 0x00, 0xF0, 0x10,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
	0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xFF,
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	0x38, 0x44, 0x44, 0x38, 0x44,
	0x7C, 0x2A, 0x2A, 0x3E, 0x14,
	0x7E, 0x02, 0x02, 0x06, 0x06,
	0x02, 0x7E, 0x02, 0x7E, 0x02,
	0x63, 0x55, 0x49, 0x41, 0x63,
	0x38, 0x44, 0x44, 0x3C, 0x04,
	0x40, 0x7E, 0x20, 0x1E, 0x20,
	0x06, 0x02, 0x7E, 0x02, 0x02,
	0x99, 0xA5, 0xE7, 0xA5, 0x99,
	0x1C, 0x2A, 0x49, 0x2A, 0x1C,
	0x4C, 0x72, 0x01, 0x72, 0x4C,
	0x30, 0x4A, 0x4D, 0x4D, 0x30,
	0x30, 0x48, 0x78, 0x48, 0x30,
	0xBC, 0x62, 0x5A, 0x46, 0x3D,
	0x3E, 0x49, 0x49, 0x49, 0x00,
	0x7E, 0x01, 0x01, 0x01, 0x7E,
	0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
	0x44, 0x44, 0x5F, 0x44, 0x44,
	0x40, 0x51, 0x4A, 0x44, 0x40,
	0x40, 0x44, 0x4A, 0x51, 0x40,
	0x00, 0x00, 0xFF, 0x01, 0x03,
	0xE0, 0x80, 0xFF, 0x00, 0x00,
	0x08, 0x08, 0x6B, 0x6B, 0x08,
	0x36, 0x12, 0x36, 0x24, 0x36,
	0x06, 0x0F, 0x09, 0x0F, 0x06,
	0x00, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x00, 0x10, 0x10, 0x00,
	0x30, 0x40, 0xFF, 0x01, 0x01,
	0x00, 0x1F, 0x01, 0x01, 0x1E,
	0x00, 0x19, 0x1D, 0x17, 0x12,
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00,
};

#define abs(X) ( ( (X) < 0 ) ? -(X) : (X) )
#define sgn(X) ( ( (X) < 0 ) ? -1 : 1 )

const uint8_t width = 128;
const uint8_t height = 160;
uint8_t madctl;
uint8_t lcd_initialized=0;

void lcd_delay_pool(uint16_t time2delay) {
	volatile uint32_t dummy = 0;

	for (dummy = time2delay*500; dummy > 0 ; dummy--);
}




void lcd_init() {

	if(lcd_initialized==0){

		//Turn on GPIOA and B clocks, and also the AFIO clock for alternate function registers
		RCC->APB2ENR|=  RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPBEN | RCC_APB2ENR_AFIOEN;


		//GPIOA pin 0 backlight (CNF 0b00 for push-pull and MODE 0b11 for 50MHz)
		GPIOA->CRL &= ~GPIO_CRL_CNF0;
		GPIOA->CRL |= GPIO_CRL_MODE0;

		//Turn on backlight
		SET_GPIO_BIT(GPIOA,0);

		//GPIOA pin 5 SCK alternate function (CNF 0b10 for AF push-pull and MODE 0b11 for 50MHz)
		GPIOA->CRL &= ~GPIO_CRL_CNF5;
		GPIOA->CRL |= GPIO_CRL_CNF5_1;
		GPIOA->CRL |= GPIO_CRL_MODE5;

		//GPIOA pin 7 SDA alternate function (CNF 0b10 for AF push-pull and MODE 0b11 for 50MHz)
		GPIOA->CRL &= ~GPIO_CRL_CNF7;
		GPIOA->CRL |= GPIO_CRL_CNF7_1;
		GPIOA->CRL |= GPIO_CRL_MODE7;

		//GPIOA pin 8 RS out (CNF 0b00 for push-pull and MODE 0b11 for 50MHz)
		GPIOA->CRH &= ~GPIO_CRH_CNF8;
		GPIOA->CRH |= GPIO_CRH_MODE8;

		//GPIOA pin 4 SS out (CNF 0b00 for push-pull and MODE 0b11 for 50MHz)
		GPIOA->CRL &= ~GPIO_CRL_CNF4;
		GPIOA->CRL |= GPIO_CRL_MODE4;

		//Turn on SS
		SET_GPIO_BIT(GPIOA,4);

		//Disable JTAG's JTRST to free GPIOB pin 4
		//Note: this is probably unnecessary as the pin will be configured as a general purpose output pin
		//but maybe removing this freaks out the JTAG? NJTRST is enabled by default...
		AFIO->MAPR &= ~AFIO_MAPR_SWJ_CFG;
		AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_NOJNTRST;

		//GPIOB pin 4 RESET out (CNF 0b00 for push-pull and MODE 0b11 for 50MHz)
		GPIOB->CRL &= ~GPIO_CRL_CNF4;
		GPIOB->CRL |= GPIO_CRL_MODE4;

		//Turn on SPI 1 clock
		RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;

		//2 lines full duplex, Master mode, 8 bits, CPOL High, CPHA 2 edges, SSM and SSI enabled for software slave control, SPI enable
		SPI1->CR1 = 0x307|SPI_CR1_SPE;

		RESET_GPIO_BIT(GPIOA,4);
		SET_GPIO_BIT(GPIOB,4);

		lcd_delay_pool(500);

		RESET_GPIO_BIT(GPIOB,4);

		lcd_delay_pool(500);

		SET_GPIO_BIT(GPIOB,4);

		lcd_delay_pool(500);

		lcd_send_commnad(ST7735_SWRESET); // software reset

		lcd_delay_pool(150);

		lcd_send_commnad(ST7735_SLPOUT);  // out of sleep mode

		lcd_delay_pool(500);

		lcd_send_commnad(ST7735_FRMCTR1);  // frame rate control - normal mode
		lcd_send_data(0x01);  // frame rate = fosc / (1 x 2 + 40) * (LINE + 2C + 2D)
		lcd_send_data(0x2C);
		lcd_send_data(0x2D);

		lcd_send_commnad(ST7735_FRMCTR2);  // frame rate control - idle mode
		lcd_send_data(0x01);  // frame rate = fosc / (1 x 2 + 40) * (LINE + 2C + 2D)
		lcd_send_data(0x2C);
		lcd_send_data(0x2D);

		lcd_send_commnad(ST7735_FRMCTR3);  // frame rate control - partial mode
		lcd_send_data(0x01); // dot inversion mode
		lcd_send_data(0x2C);
		lcd_send_data(0x2D);
		lcd_send_data(0x01); // line inversion mode
		lcd_send_data(0x2C);
		lcd_send_data(0x2D);

		lcd_send_commnad(ST7735_INVCTR);  // display inversion control
		lcd_send_data(0x07);  // no inversion

		lcd_send_commnad(ST7735_PWCTR1);  // power control
		lcd_send_data(0xA2);
		lcd_send_data(0x02);      // -4.6V
		lcd_send_data(0x84);      // AUTO mode

		lcd_send_commnad(ST7735_PWCTR2);  // power control
		lcd_send_data(0xC5);      // VGH25 = 2.4C VGSEL = -10 VGH = 3 * AVDD

		lcd_send_commnad(ST7735_PWCTR3);  // power control
		lcd_send_data(0x0A);      // Opamp current small
		lcd_send_data(0x00);      // Boost frequency

		lcd_send_commnad(ST7735_PWCTR4);  // power control
		lcd_send_data(0x8A);      // BCLK/2, Opamp current small & Medium low
		lcd_send_data(0x2A);

		lcd_send_commnad(ST7735_PWCTR5);  // power control
		lcd_send_data(0x8A);
		lcd_send_data(0xEE);

		lcd_send_commnad(ST7735_VMCTR1);  // power control
		lcd_send_data(0x0E);

		lcd_send_commnad(ST7735_INVOFF);    // don't invert display

		lcd_send_commnad(ST7735_MADCTL);  // memory access control (directions)
		lcd_send_data(0xC8);  // row address/col address, bottom to top refresh
		madctl = 0xC8;

		lcd_send_commnad(ST7735_COLMOD);  // set color mode
		lcd_send_data(0x05);        // 16-bit color

		lcd_send_commnad(ST7735_CASET);  // column addr set
		lcd_send_data(0x00);
		lcd_send_data(0x00);   // XSTART = 0
		lcd_send_data(0x00);
		lcd_send_data(0x7F);   // XEND = 127

		lcd_send_commnad(ST7735_RASET);  // row addr set
		lcd_send_data(0x00);
		lcd_send_data(0x00);    // XSTART = 0
		lcd_send_data(0x00);
		lcd_send_data(0x9F);    // XEND = 159

		lcd_send_commnad(ST7735_GMCTRP1);
		lcd_send_data(0x0f);
		lcd_send_data(0x1a);
		lcd_send_data(0x0f);
		lcd_send_data(0x18);
		lcd_send_data(0x2f);
		lcd_send_data(0x28);
		lcd_send_data(0x20);
		lcd_send_data(0x22);
		lcd_send_data(0x1f);
		lcd_send_data(0x1b);
		lcd_send_data(0x23);
		lcd_send_data(0x37);
		lcd_send_data(0x00);
		lcd_send_data(0x07);
		lcd_send_data(0x02);
		lcd_send_data(0x10);
		lcd_send_commnad(ST7735_GMCTRN1);
		lcd_send_data(0x0f);
		lcd_send_data(0x1b);
		lcd_send_data(0x0f);
		lcd_send_data(0x17);
		lcd_send_data(0x33);
		lcd_send_data(0x2c);
		lcd_send_data(0x29);
		lcd_send_data(0x2e);
		lcd_send_data(0x30);
		lcd_send_data(0x30);
		lcd_send_data(0x39);
		lcd_send_data(0x3f);
		lcd_send_data(0x00);
		lcd_send_data(0x07);
		lcd_send_data(0x03);
		lcd_send_data(0x10);

		lcd_send_commnad(ST7735_DISPON);

		lcd_delay_pool(100);

		lcd_send_commnad(ST7735_NORON);  // normal display on

		lcd_delay_pool(10);

		lcd_draw_fillrect(0, 0 , LCD_WIDTH, LCD_HEIGHT, 0x0000) ;

		lcd_initialized=1;

	}else{
		lcd_draw_fillrect(0, 0 , LCD_WIDTH, LCD_HEIGHT, 0x0000) ;
	}
}

void lcd_send_commnad(  uint8_t txCommand ) {

	RESET_GPIO_BIT(GPIOA,8);
	RESET_GPIO_BIT(GPIOA,4);
	lcd_spi_send(txCommand);
	SET_GPIO_BIT(GPIOA,4);

}

void lcd_send_data( uint8_t txData ) {

	SET_GPIO_BIT(GPIOA,8);
	RESET_GPIO_BIT(GPIOA,4);
	lcd_spi_send(txData);
	SET_GPIO_BIT(GPIOA,4);
}

uint8_t lcd_spi_send( uint8_t txByte ) {

	while((SPI1->SR&0x2)==0);

	SPI1->DR = txByte;

	while((SPI1->SR&0x1)==0);

	/* Return the byte read from the SPI bus */
	return SPI1->DR;
}

void lcd_draw_string(uint8_t x, uint8_t y, char *c, uint16_t color, uint8_t size) {
	while (c[0] != 0)
	{
		lcd_draw_char(x, y, c[0], color, size);
		x += size*6;
		c++;
		if (x + 5 >= width)
		{
			y += 10;
			x = 0;
		}
	}
}

void lcd_draw_pixel(uint8_t x, uint8_t y, uint16_t color) {
	if ((x >= width) || (y >= height)) return;
	lcd_setAddrWindow(x,y,x+1,y+1);

	SET_GPIO_BIT(GPIOA,8);
	RESET_GPIO_BIT(GPIOA,4);

	lcd_spi_send(color >> 8);
	lcd_spi_send(color);

	SET_GPIO_BIT(GPIOA,4);
}

void lcd_draw_line(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint16_t color) {

	 int i,dx,dy,sdx,sdy,dxabs,dyabs,x,y,px,py;

	 lcd_setAddrWindow(x1, y1, x2, y2);

	 SET_GPIO_BIT(GPIOA,8);
	 RESET_GPIO_BIT(GPIOA,4);

	 if ( x1==x2 )  //Vertical Line
	 {
		 if ( y1 > y2 ) //We assume y2>y1 and invert if not
		 {
			 i = y2;
			 y2 = y1;
			 y1 = i;
		 }
		 lcd_draw_fillrect( x1, y1, 1, y2-y1+1, color );
		 return;
	 }
	 else if ( y1==y2 )  //Horizontal Line
	 {
		 if ( x1 > x2 ) //We assume x2>x1 and we swap them if not
		 {
			 i = x2;
			 x2 = x1;
			 x1 = i;
		 }
		 lcd_draw_fillrect( x1, y1, x2-x1+1, 1, color );
		 return;
	 }

	 dx=x2-x1;      /* the horizontal distance of the line */
	 dy=y2-y1;      /* the vertical distance of the line */
	 dxabs=abs(dx);
	 dyabs=abs(dy);
	 sdx=sgn(dx);
	 sdy=sgn(dy);
	 x=dyabs>>1;
	 y=dxabs>>1;
	 px=x1;
	 py=y1;

	 if (dxabs>=dyabs) /* the line is more horizontal than vertical */
	 {
		 for(i=0;i<dxabs;i++)
		 {
			 y+=dyabs;
			 if (y>=dxabs)
			 {
				 y-=dxabs;
				 py+=sdy;
			 }
			 px+=sdx;
			 lcd_draw_pixel(px,py,color);
		 }
	 }
	 else /* the line is more vertical than horizontal */
	 {
		 for(i=0;i<dyabs;i++)
		 {
			 x+=dxabs;
			 if (x>=dyabs)
			 {
				 x-=dyabs;
				 px+=sdx;
			 }
			 py+=sdy;
			 lcd_draw_pixel(px,py,color);
		 }
	 }

	 SET_GPIO_BIT(GPIOA,4);
 }

void lcd_draw_rect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint16_t color) {

   lcd_setAddrWindow(x, y, x+w-1, y+h-1);

   SET_GPIO_BIT(GPIOA,8);
   RESET_GPIO_BIT(GPIOA,4);

   lcd_draw_line( x, y, x+w, y,color);
   lcd_draw_line( x, y, x, y+h,color);
   lcd_draw_line( x+w, y, x+w, y+h,color);
   lcd_draw_line( x, y+h, x+w, y+h,color);

   SET_GPIO_BIT(GPIOA,4);
 }

void lcd_draw_fillrect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint16_t color) {

  lcd_setAddrWindow(x, y, x+w-1, y+h-1);

  SET_GPIO_BIT(GPIOA,8);
  RESET_GPIO_BIT(GPIOA,4);

  for (x=0; x < w; x++) {
    for (y=0; y < h; y++) {
      lcd_spi_send(color>>8 );
      lcd_spi_send(color);
    }
  }
  SET_GPIO_BIT(GPIOA,4);
}

void lcd_setAddrWindow( uint8_t x,uint8_t y,uint8_t x1,uint8_t y1 ) {
	lcd_send_commnad(ST7735_CASET);
	lcd_send_data(0x00);
	lcd_send_data(x+0);
	lcd_send_data(0x00);
	lcd_send_data(x1+0);

	lcd_send_commnad(ST7735_RASET);
	lcd_send_data(0x00);
	lcd_send_data(y+0);
	lcd_send_data(0x00);
	lcd_send_data(y1+0);
	lcd_send_commnad(ST7735_RAMWR);
}

void lcd_draw_pixelFromChar(uint8_t x, uint8_t y, uint16_t color){
	//if ((x >= width) || (y >= height)) return;
	lcd_setAddrWindow(x,y,x+1,y+1);

	SET_GPIO_BIT(GPIOA,8);
	RESET_GPIO_BIT(GPIOA,4);

	lcd_spi_send(color >> 8);
	lcd_spi_send(color);

	SET_GPIO_BIT(GPIOA,4);
}

void lcd_draw_char(uint8_t x, uint8_t y, char c, uint16_t color, uint8_t size) {

    for(int8_t i=0; i<6; i++ ) {
      uint8_t line;
      if(i < 5) line = (uint8_t) font[(c*5)+i];
      else      line = 0x0;
      for(int8_t j=0; j<8; j++, line >>= 1) {
        if(line & 0x1) {
          if(size == 1) lcd_draw_pixelFromChar(x+i, y+j, color);
          else          lcd_draw_fillrect(x+i*size, y+j*size, size, size, color);
        } else if(0x0000 != color) {
          if(size == 1) lcd_draw_pixelFromChar(x+i, y+j, 0x0000);
          else          lcd_draw_fillrect(x+i*size, y+j*size, size, size, 0x0000);
        }
      }
    }
}

void lcd_draw_char2(uint8_t x, uint8_t y, char c, uint16_t color, uint8_t size) {
	uint8_t line, i, j;

	//lcd_setAddrWindow(x,y,x+10,y+16);

	for (i =0; i<5; i++ )
	{
		line =  (uint8_t) font[(c*5)+i];
		for (j = 0; j<8; j++)
		{
			if ( (line >> j ) & 0x1 )
			{
				if (size == 1) // default size
					lcd_draw_pixelFromChar(x+i, y+j, color);
				else
				{  // big size
					lcd_draw_fillrect(x+i*size, y+j*size, size, size, color);
				}
			}
			else
			{}
			//	lcd_draw_pixel(x+i, y+j, 0x0000);
			//line >>= 1;
		}
	}
}

void lcd_draw_circle(int16_t x0, int16_t y0, int16_t r, uint16_t color) {
  int16_t f = 1 - r;
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
  int16_t x = 0;
  int16_t y = r;

  lcd_draw_pixel(x0 , y0+r, color);
  lcd_draw_pixel(x0 , y0-r, color);
  lcd_draw_pixel(x0+r, y0 , color);
  lcd_draw_pixel(x0-r, y0 , color);

  while (x<y) {
    if (f >= 0) {
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x;

    lcd_draw_pixel(x0 + x, y0 + y, color);
    lcd_draw_pixel(x0 - x, y0 + y, color);
    lcd_draw_pixel(x0 + x, y0 - y, color);
    lcd_draw_pixel(x0 - x, y0 - y, color);
    lcd_draw_pixel(x0 + y, y0 + x, color);
    lcd_draw_pixel(x0 - y, y0 + x, color);
    lcd_draw_pixel(x0 + y, y0 - x, color);
    lcd_draw_pixel(x0 - y, y0 - x, color);
  }
}

//New filled circle function, shamelessly stolen from here:
//http://stackoverflow.com/questions/1201200/fast-algorithm-for-drawing-filled-circles

//Uses the algorithm described by user "palm3D" with user "Dwight"'s slight modification. 0.7f works better for this LCD size
void lcd_draw_fillcircle(int16_t x0, int16_t y0, int16_t r, uint16_t color){
	for(int y=-r; y<=r; y++)
	    for(int x=-r; x<=r; x++)
	        if(x*x+y*y <= r*r + r*0.7f)
	        	lcd_draw_pixel(x0+x,y0+y, color);
}
